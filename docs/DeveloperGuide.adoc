= ModPlan v1.3 - Developer's Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-F10-1/main

By: `Team AY1920S1-CS2113T-F10-1`      Since: `Aug 2019`      License: `NUS School of Computing`

== Introduction

*ModPlan*

ModPlan is a module planning system that expands on NUSMODS to help NUS students to plan their modules for all four years of their bachelorâ€™s degree.  +

ModPlan is currently only designed to work for Computer Engineering students, and the requisite modules for graduation. +
ModPlan uses NUSMODS API to extract official module data from the NUS Registrar's Office. + 

This Developer Guide is meant for any software developer who wishes to contribute to or test ModPlan, and can find architecture, implementation methods and high-level design considerations within this file.

== Setting up

**Prerequisites**

* JDK version:  `11` or above
* Recommended IDE: `IntelliJ IDEA`
* Fork this repo to your GitHub account and clone the fork to your computer

**Importing the project into IntelliJ**

1. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first).
2. Set up the correct JDK version.
   * Click `Configure` > `Structure for new Projects` (in older versions of Intellij:`Configure` > `Project Defaults` > `Project Structure`).
   * If JDK 11 is listed in the drop down, select it. If it is not, click `New...` and select the directory where you installed JDK 11.
   * Click `OK`.
3. Click `Import Project`.
4. Locate the project directory and click `OK`.
5. Select `Create project from existing sources` and click `Next`.
6. Rename the project if you want. Click `Next`.
7. Ensure that your src folder is checked. Keep clicking `Next`.
8. Click `Finish`.

**Running the Project**

* If you wish to run the .jar file in a mainstream OS, simply double click the .jar file, and a command line interface should run in a few seconds. +
This is assuming you have a JDK version of `11` and above.

* If you are not using `gradle`, simply locate the `Planner.java` file under `PROJECT_DIRECTORY/src/main/java/planner/Planner.java`, and run it in your IDE.

* If you are using `gradle`, import the project as a gradle project using the `Import Gradle Project` function in IntelliJ, and run `gradlew run` from the command line.

== Overall Design

=== Architecture

Our integration approach would be bottom-up, since we are morphing the original Duke Assistant into our ModPlanner application, some of the components can be adapted and reused of other purposes. +

The high-level UML Diagram of ModPlan can be seen below:

image::Architecture.png[]

In that way, our implementation approach would also be incremental as oppose to big-bang, since we would need to gradually alter and test out which portions of Duke is reusable in ModPlanner.


=== JsonWrapper

The main wrapper over requesting data from NUSMODS API, Gson library for JSON parsing and Natty for relative date processing. Dependant on Storage class for writing data files obtained.

image::JsonWrapper.png[width="350"]

This class is also dependant on a RequestsData class which serves as the main API caller for ModPlanner, but it is not used anywhere else in the code base.

=== Storage

Main class which handles file writing during runtime and for maintaining user data in memory.

image::Storage.png[width="350"]

This class was adapted from the existing Duke storage to suit the needs of ModPlanner.

=== Parser

Our parser is based on an external library, Argsparsej. It is comprehensive in its coverage as a command line parsers, hence it become our choice for implementing the main parser for user commands.

image::Parser.png[]

=== PlannerUi

The main class which handles user display, which includes reading user input and printing module, CAP and CCA information back to the user on command-line.

image::PlannerUi.png[]

=== Command

Using Java's built in OOP, this abstract class is implemented in each of the specific commands seen by our parser. For developers, this is the main class of interest to build additional functionality to ModPlanner.

image::Command.png[]

The arguments to implemented command classes are handled by the Arguments class which is returned from our Parser.

=== CCA

Building on additional functionality, our implementation of CCA would inherit from legacy Tasks class from Duke, allowing both modules and CCAs to be stored in the same TaskList collection.

image::CCA.png[]


== Implementation
This section explains and shows diagrams of how certain features of ModPlan are implemented.

***

=== GradeCommand
==== Current Implementation
The `grade` feature is operated by the `GradeCommand` class, which is called by the `Argsparse4jWrapper` class. Upon user input of `grade MODULECODE LETTERGRADE`, the Parser will return a new `GradeCommand`.

Since `GradeCommand` inherits the `ModuleCommand` class, it must override the `execute` method to specially execute the `grade` command.
From the `Argsparse4jWrapper`, `GradeCommand` also receives two additional variable inputs from the user: +

. The module code of the module to be graded.
. The letter grade attained for the module that the user specifies above.

There are two ways that the execute method can execute, depending upon whether the moduleCode the user enters is in their moduleTaskList or not.

****

* Case 1: Module is not in the task list +
If the module is not in the task list, `GradeCommand` executes in a similar fashion to `SearchThenAddCommand`, creating a temporary `ModuleInfoDetailed` class to check if the moduleCode entered by the user exists or not. +
Following which, the letterGrade of the module is set using the method `setGrade` under the `ModuleInfoDetailed` class.
+
** *Note:* The `setGrade` method will check if the letterGrade input by the user is valid (a valid letter grade, as well as S/U capabilities).
+
If the letter grade is invalid, either `ModModBadSUException` or `ModBadGradeException` will be thrown.
+
Finally, the temporary module will be added to the `ModuleTaskList`, with the `letterGrade` included in its details.

* Case 2: Module is in the task list
If the module already exists in the task list, (i.e `ModuleTaskList` contains `moduleCode`) `GradeCommand` will simply check if the module can be S/U-ed, and update the `letterGrade` according to what the user inputs using the `setGrade` method.

****

Below is a Sequence Diagram showing how `GradeCommand` works.

==== Design Considerations
*How GradeCommand executes*

Checks had to be implemented to check if the module can be S/U-ed, as well as if the `letterGrade` the user inputs is a valid grade according to NUS specifications.
These checks were implemented into the `ModuleInfoDetailed` class itself, which `ModuleTask` inherits as the baseline of the module task list. This way, other classes are able to use the methods and checks to set the letter grade for the respective module.

***

=== CapCommand
==== Current Implementation
The `cap` feature is operated by the `CapCommand` class, which is called by the `Argsparse4jWrapper` class. Upon user input of `cap TYPE`, the Parser will return a new `CapCommand`. +

Since `CapCommand` inherits the `ModuleCommand` class, it must override the `execute` method to specially execute the `cap` command. +

The parameter `TYPE` can take three forms according to the user input. +
`cap overall` Where the user inputs modules of their choosing, as well as the letter grade, and the CAP is calculated accordingly. +
`cap list` Where the user's CAP is calculated from the modules with letter grades in the module task list. +
`cap module` Where the CAP of a module of the user's choosing can be calculated using the grades of prerequisite modules that the user has completed. +

These `TYPE` parameters will be parsed by the `Argsparse4jWrapper` class and pass the corresponding argument of `toCap` into the `CapCommand` class. A switch case statement will handle the `toCap` argument, and choose to execute from three methods accordingly: +
`calculateOverallCap`,
`calculateListCap`
and
`calculateModuleCap` +

Upon construction of the `CapCommand` class, a few variables involved in calculating the CAP of the user are initialized, notably the users `mcCount`, `currentCap`, `projectedModuleCap` and `projectedCap`. These variables will be used in the three different ways CapCommand can currently execute in.

As stated above, there are three methods that can be executed depending upon the `TYPE` the user inputs.

****
* Case 1: `cap overall` +
If the argument read for `toCap` is "overall", the `calculateOverallCap` method will be executed under the `execute` method. +
Firstly, a new `Scanner` will be created to continue reading in the modules and grades that the user wishes to calculate their CAP for. +
The user will be prompted to input a module and its respective letter grade. The system will automaticall convert the letter grade to NUS specifications according to the below chart +

image::CAPchart.png[align="center"]

The user inputs are read in until the user inputs `done`, proceeding which the scanner will close and the calculation is done +
Finally the user's CAP is calculated and printed according to NUS guidelines using the below formula: +

image::CAPformula.png[align="center"]

****

=== JsonWrapper

==== Current implementation

`JsonWrapper` contains our usage of the `Gson` library for JSON file processing, as well as to call `RequestsData` to obtained the module data consolidated by `NUSMODS API`.

To prevent multiple requests to NUSMODS, our implementation would check if the user has previously downloaded the module data before. If they have only, only then would `JsonWrapper` call `RequestsData` to initialize the module data file.

image::PackageCrawler.png[]

Since `Gson` is able to internally read a JSON file and when given the same template within a Java object class, it would be able to map the value fields to each of the same keys in the Java Object.

This allows us to have a direct access to all the modules which are currently offered in NUS, by reading the returned JSON string and parsing it directly into a list of Module information. Since the data had to be modelled, the +
following ModuleInfoDetailed and ModuleInfoSummary was created to capture the data in the JSON file to be used during runtime.

image::PackageModule.png[]

Since certain modules may not contain data for every field, each of the module classes above are required to have default values on startup so as to prevent `NullPointerExceptions` during runtime when such data is accessed.
This also extends to choosing the right data type for modelling our module information, since certain fields maybe malformed and thus our implementation of the fields data type in module information classes would mostly contain `strings`, unless it is certain that
the data type found in the returned JSON string is strictly `boolean` or `double`.

To allow for quick access to the module information classes, after parsing of the module information into a list of `ModuleInfoDetailed`, it would then be converted into a `HashMap`, where the key-value pair
is the string containing the module code, and the value is the `ModuleInfoDetailed`. This is what is exposed to all the command classes during runtime, and this is done automatically on startup so that the module
data is accessible directly to the user.

==== RequestsData

Internally, this class is responsible for requesting data from the `NUSMODS API` and thus uses Java's Native `HTTPRequest` Library.

The current implementation is fixed to only request data for the current academic year, but this is subject to change in the coming versions to allow for users to choose to update the data once it gets outdated.


[appendix]
== Product Scope

*A better module planner*

We aim to fulfill a need that is currently lacking in module planning, which in this case the is ability to plan ahead for more semesters up until graduation. Additional features would likely include the ability to generate a projection report for CAP computation and CCA planning.

[appendix]
== User Stories
Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I can ... |So that ...
|`* * *` |NUS CEG Student |Search for a module's workload |Balance my workload for the current semester
|`* * *` |NUS CEG Student |Monitor my total workload from my modules |Track my total workload for the current semester 
|`* * *` |NUS Student |See my daily timetable |Keep a schedule of what classes and extra-curricular activities I have 
|`* * *` |NUS CEG Student |Check if I have completed the required prerequisite modules |Plan ahead for what modules to take 
|`* * *` |Forgetful NUS CEG Student |Add up my total number of MCs taken |Track my progress towards graduation 
|`* * *` |NUS CEG Student |View the core modules required for graduation |Know what are the modules I still need to take to graduate 
|`* *` |NUS Student |Add CCAs to my class timetable |Take CCAs that do not clash with my lessons 
|`* *` |NUS Student |Create a custom module for my CCAs |Personalise the timing and location of my CCA in my timetable 
|`* *` |NUS Undergraduate Student |Know requirements for a Master's/PHD at NUS |Plan my course of action if I wish to apply for post-graduate studies 
|`* *` |NUS CEG Student |Easy access to my recommended study schedule |Know what modules I should prioritise bidding for 
|`* *` |NUS CEG Student |Plan to take modules ahead of the current semester |Alter my holiday/graduation plans as required 
|`* *` |NUS CEG Student |Know what GE modules I have not completed |Plan to take GE modules over a few semesters 
|`* *` |NUS CEG Student |View the total number of Level-1000 modules taken |Check if I have exceeded the 60MC limit for Level-1000 modules
|`* *` |NUS CEG Student |Know if the module has S/U options |Plan ahead for my S/U usage 
|`* *` |NUS CEG Student |Project my future CAP based on my expected and past grades |See how hard I must work to hit my target CAP 
|`*` |NUS CEG Student |Download my timetable as a photo |View it on other mediums such as my mobile phone 
|`*` |NUS Student |Know the directions to my classes |Plan my route accordingly 
|`*` |NUS Student |Know my priority score when bidding for a module |Plan my module bidding appropriately 
|`*` |NUS Student |See a list of my course's modules available in SEP/NOC |Plan what modules to take should I go for SEP/NOC 
|`*` |Exchange Student |Know if a module can be mapped to my home university |Plan what modules to take in NUS 

|=======================================================================
(more to be added in v2.0 as necessary)

[appendix]
== Use Cases

=== Use Case C01: Adding modules to user's timetable
Actor: NUS CEG Student

*MSS*

1. User inputs the module code
2. ModPlan shows the module information to the user, such as description, number of MCs, prerequisite modules etc. and requests confirmation from the user to add this module
3. User confirms they want to add the module 
4. ModPlan shows the non-clashing available timings of the module to the user
5. User confirms which class timing they wish to add to their timetable
6. ModPlan adds that specific class to the user's timetable, and prints the user's updated timetable +
Use case ends.

*Extensions*

2a1. If the module is a Level-1000 module, ModPlan checks for the user's current number of Level-1000 modules taken +
2a2. If the limit is not exceeded, proceed to step 3 +
2a3. If the limit will be exceeded, warn the user, and prevent addition of the module +
2a4. Additionally, if the prerequisites of the module have not been fulfilled, prevent addition of the module, and inform user of the modules needed to be taken +
Return to step 3.

=== Use Case C02: Viewing graduation requirements
Actor: NUS CEG Undergraduate Student

*MSS*

1. User inputs their course name
2. ModPlan shows the courses that match the user's input
3. User selects the correct course they wish to check graduation requirements for
4. ModPlan displays all the modules required for graduation, and lists the number of MCs required for graduation +
Use case ends.

*Extensions*

3a. User can input the modules they have taken already that count towards graduating that course
3b. ModPlan will exclude these modules from the list and MC count +
Return to Step 4.

=== Use Case C03: Viewing class and CCA timetable
Actor: NUS Student

*MSS*

1. User inputs the command to view timetable
2. ModPlan shows the user their current timetable, including class and CCA timings

=== Use Case C04: Viewing of modules taken in past semester
Actor: NUS Student

*MSS*

1. User inputs the command to view past modules
2. ModPlan shows the user a list of all modules taken, and those they are currently taking. +
Use case ends.

=== Use Case C05: Generation of current CAP based on past modules
Actor: NUS Student

*MSS*

1. User inputs the command to generate CAP report
2. ModPlan shows the user modules they had taken, and requests user to input their grades obtained
3. User inputs the modules they have taken, as well as the respective grades obtained
4. After inputting the grades, ModPlan calculates and shows the user their current MCs accumulated and CAP. +
Use case ends.

*Extensions*

4a. User can then input a future module they plan to take and project their CAP
4b. ModPlan will show the projected CAP using grades the user obtained from the module's prerequisite classes

=== Use Case C06: Check Module information via input search
Actor: NUS Student

*MSS*

1. User inputs the command to search module information
2. ModPlan shows the user key information regarding the module, if it is SU-able or if it has any prequisites. +
Use case ends.

=== Use Case C07: Creating a personalised Module (eg. for CCAs)
Actor: NUS Student

*MSS*

1. User inputs the command to create custom module
2. ModPlan prompts the user for additional details of the custom module, such as description and times
3. User inputs the description and date/times
4. ModPlan prompts user to confirm addition of custom module to timetable
5. User confirms addition
6. ModPlan adds custom module to timetable, and shows user updated timetable. +
Use case ends.

*Extensions*

5a. User can cancel addition + 
5b. ModPlan will cancel addition of custom module, and delete information inputted

=== Use Case C08: Checking number of MCs taken
Actor: NUS Student

*MSS*

1. User inputs the command to check MC
2. ModPlan will show the total MCs taken up to this point. +
Use case ends.

*Extensions*

1a. User can specify additional parameters to check MCs completed for specific periods +
eg. `check MC 1-1` will check for MCs taken in Year 1 Semester 1

[appendix]
== Non-Functional Requirements

1. ModPlan should run on any machine with JDK `11` and above installed. 
2. ModPlan should be fast to view and input commands.
3. ModPlan should require as few steps as possible for the user to do what they want to do.
4. ModPlan should store data between sessions so the user does not have to input all their information again.
5. ModPlan should scrape data from NUSMODS API at least once a day to keep up to date with any changes in modules.


[appendix]
== Glossary
* *API* : Application Programming Interface
* *CEG* : Computer Engineering
* *NUSMODS* : NUSMODS is an external library where consolidated module data from NUS is collected
* *JSON* : JavaScript Object Notation
